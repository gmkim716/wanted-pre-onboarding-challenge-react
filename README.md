# wanted-pre-onboarding-challenge-react-gmkim716
:: 원티드 프리온보딩 챌린지 프론트엔드 코스 사전과제

참가자 여러분은 강의에 참여하기 전에 다음의 면접형 문제들을 사전에 작성해 주시기 바랍니다. 
이 문제들은 JavaScript, React, 그리고 Next.js에 대한 깊이 있는 이해를 바탕으로 준비되었습니다.

# 과제

## 1. JavaScript ES6+ 기능
**문제:**
JavaScript ES6 이후에 추가된 주요 기능 중에서, 템플릿 리터럴, 화살표 함수, 스프레드 연산자를 설명하고, 
이러한 기능들이 JavaScript 프로그래밍에 어떤 이점을 제공하는지 구체적인 예를 들어 설명해 주세요.

- 템플릿 리터럴 : 백틱(`)을 이용해 문자열을 작성하는 방법, 문자열 내에서 표현식을 삽입하거나 여러 줄의 문자열을 쉽게 작성할 수 있다. 

- 화살표 함수 : function 키워드를 사용해야 하는 대신 => 를 이용해서 함수를 간결하게 작성할 수 있는 문법

- 스프레드 연산자 : `...`을 이용해 배열이나 객체 요소를 쉽게 복사하거나 병합할 수 있게 해준다.

## 2. React 컴포넌트의 종류와 차이
**문제:**
함수형 컴포넌트와 클래스형 컴포넌트를 비교 설명하고, React Hooks가 도입된 배경과 이로 인해 달라진 React 개발 방식에 대해 설명해 주세요.

- 함수형 컴포넌트
  
  - `useState` 훅을 사용해서 상태를 관리한다.
  - `useEffect` 훅을 이용해 생명주기 메서드 기능을 대체한다.
  - 클래스형 보다 코드가 간결하고 이해하기 쉽다.

- 클래스형 컴포넌트

  - ES6 클래스 문법을 사용해 정의된 컴포넌트
  - `this.state`를 사용해 상태를 관리한다.
  - `componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 등의 메서드를 사용해 생명주기 동안 특정 작업을 수행할 수 있다.
  - 클래스 메서드 내에서 `this` 키워드를 사용해야 하고, 메서드 바인딩이 필요하다.

- react hooks 도입 배경

  1. 상태 관련 로직을 훅으로 분리해서 재사용할 수 있게 되었다.

  2. 클래스형 컴포넌트에서는 생명주기 메서드가 여러 개 존재해서 복잡한 로직을 구현하기 어려웠지만, Hooks는 함수 내에서 로직을 선언적으로 작성할 수 있어 코드가 더 간결해졌다.
  
  3. 클래스형 컴포넌트에서는 this 바인딩 문제와 복잡한 메서드 구조로 인해 코드를 읽기 어려웠다.
  
- hooks 도입으로 달라진 개발 방식 

  1. **함수형 컴포넌트**가 클래스형 컴포넌트를 대체하는 방식으로 자리잡아 코드의 간결성과, 가독성을 높였다.

  2. **커스텀 훅**을 작성해서 사용함으로써 코드 재사용성을 크게 향상시켰다.

  3. useEffect를 사용해 **생명주기 메서드를 간단하게 대체**할 수 있게 되었다. 코드가 더 직관적이고 이해하기 쉬워졌다.

  4. useState, useReducer 등을 사용해 복잡한 **상태관리를 간소화**하고 체계적으로 관리할 수 있게 되었다.
  

## 3. Next.js의 App Path Routing
**문제:**
Next.js 12.2 버전부터 도입된 App Path Routing에 대해 설명하고, 이전의 페이지 기반 라우팅과 어떻게 다른지, 그리고 이 새로운 라우팅 방식이 개발자에게 어떤 이점을 제공하는지 분석해 주세요.

- 기존의 Page Routing

  - pages 디렉토리에 각 파일이 라우트로 매핑되는 방식

  - 중첩 라우팅이 기본적으로 지원되지 않아 복잡한 UI 구조를 만드는데 제한적이다.


- App Routing

  - 폴더 기반 레이아웃 : 페이지와 레이아웃을 명확하게 구조할 수 있어 복잡한 구조에서도 사용이 원활하다

  - React18 기능 활용 : Concurrent Mode와 Server Component를 활용해 성능을 극대화하고, 사용자 경험을 개선할 수 있다. 

  - SSR 컴포넌트를 쉽게 작성해서, CSR을 줄이고 성능을 개선하게 되었다
 
  ```
  ※ 추가 설명
  
  - '/blog', 'blog/:id' 경로에 대해 각각의 페이지가 독립적으로 존재하기 때문에, 기존의 page routing 방식에서는 동일한 레이아웃에 대해 각 페이지 파일에서 코드를 반복해야 하는 번거로움이 발생했다.
  
  - App Router 도입 이후로 `getStaticProps`, `getStaticPaths`, `getServerSideProps`와 같은 메서드는 더이상 사용되지 않는다. 'use client;'를 사용하지 않는 이상, 컴포넌트는 기본적으로 서버에서 동작한다.
  ```

## 4. 서버 사이드 렌더링과 정적 사이트 생성
**문제:**
Next.js에서 서버 사이드 렌더링(SSR)과 정적 사이트 생성(SSG)의 차이를 설명하고, 각각 어떤 시나리오에서 사용되어야 하는지 예를 들어 설명해 주세요.

- SSR 

  - 

- SSG 

  - build 시점에 페이지를 미리 렌더링해서 HTML 파일을 생성한다. 사전에 작성된 HTML 파일을 사용자에게 전달하기 때문에 서버 부하가 적다. 


# 제출
- 저장소의 issues 탭을 클릭하고, new issue 버튼을 클릭합니다. 
- 프리온보딩 챌린지 템플릿을 선택하고 답변을 작성합니다.
- 제목은 제출일 - 이름 으로 작성해서 제출해주시면 됩니다.

